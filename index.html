<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
    <title>Tetris Leaderboard BG</title>
    <style>
        html, body {
            margin: 0; padding: 0;
            background: url('./background.png') center center / cover no-repeat;
            min-height: 100vh;
        }
        body {
            text-align: center;
            font-family: Arial, sans-serif;
            color: #ddd;
        }
        #container {
            max-width: 420px;
            margin: auto;
            padding: 10px 0 40px 0;
            position: relative;
        }
        canvas {
            border: 4px solid #6A0DAD;
            border-radius: 12px;
            box-shadow: 0 0 20px #6A0DAD, 0 0 40px #220044;
            display: block;
            margin: 20px auto 8px auto;
            background-color: rgba(0, 0, 0, 0.7);
            width: 340px;
            height: 400px;
            touch-action: none;
        }
        @media (max-width: 450px) {
            canvas {
                width: 96vw;
                height: 113vw;
                max-width: 98vw;
                max-height: 90vh;
            }
            #leaderboard {
                width: 97vw;
                font-size: 15px;
            }
        }
        #leaderboard {
            margin: 10px auto 12px auto;
            width: 350px;
            background: rgba(16, 7, 30, 0.95);
            border-radius: 12px;
            box-shadow: 0 0 8px #6A0DAD;
            padding: 10px;
            color: #fff;
            font-size: 16px;
        }
        #leaderboard th, #leaderboard td {
            padding: 3px 8px;
        }
        #userBar {
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
        }
        .game-buttons {
            margin: 10px 0 5px 0;
        }
        .game-buttons button {
            font-size: 16px;
            margin: 0 6px;
            padding: 6px 15px;
            border-radius: 8px;
            border: none;
            background: #6A0DAD;
            color: #fff;
            box-shadow: 0 0 6px #8A2BE2;
            cursor: pointer;
        }
        .game-buttons button:active {
            background: #41115b;
        }
        #gameOverMsg {
            color: #ff369a;
            font-size: 26px;
            font-weight: bold;
            margin: 15px;
            text-shadow: 0 0 8px #000;
            display: none;
        }
        #levelAnim {
            display: none;
            position: absolute;
            left: 0; right: 0; top: 23%;
            font-size: 42px;
            font-weight: bold;
            color: #22ccff;
            text-shadow: 0 0 18px #6A0DAD, 0 0 32px #220044;
            z-index: 20;
            animation: pop 1.1s;
        }
        @keyframes pop {
            0% {transform: scale(0.5); opacity: 0;}
            30% {transform: scale(1.2); opacity: 1;}
            60% {transform: scale(0.85);}
            90% {transform: scale(1);}
            100% {opacity: 0;}
        }
    </style>
</head>
<body>
<div id="container">
    <h1>Tetris pour les bg</h1>
    <div id="userBar"></div>
    <audio id="bgMusic" src="./music.mp3" loop preload="auto"></audio>
    <div>
        <span id="score">Score: 0</span> |
        <span id="lines">Lignes: 0</span> |
        <span id="level">Niveau: 1</span> |
        <span id="timer">Temps: 0s</span>
    </div>
    <div class="game-buttons">
        <button onclick="restartGame()">Redémarrer</button>
        <button id="pauseBtn" onclick="togglePause()">Pause</button>
    </div>
    <div id="gameOverMsg"></div>
    <canvas id="tetris" width="340" height="400"></canvas>
    <div id="leaderboard">
        <b>Leaderboard mondial</b>
        <table id="lbTable" style="width:100%;margin-top:5px;">
            <thead><tr><th>Pos</th><th>Pseudo</th><th>Score</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
    <div id="levelAnim"></div>
</div>
<script>

window.addEventListener("keydown", function(e) {
    // Bloque scroll pour fleches (surtout bas) et barre espace (sur toute la page)
    if(['ArrowLeft','ArrowRight','ArrowDown',' '].includes(e.key)) {
        e.preventDefault();
    }
}, {passive: false});

    // === CONFIG JSONBIN ===
    const API_KEY = "$2a$10$QaIl/jNblmE41X0hexsVMeqBDs68V0Hpu9nSNXw7BYEcYiVWEHd4K";
    const BIN_ID = "6825bd578561e97a5014584f";
    const BIN_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
    let leaderboard = [];
    let username = null;

    // Username : demander au début, toujours
    function askUsername(force) {
        username = localStorage.getItem('tetrisUser');
        if (!username || force) {
            username = prompt("Entrez votre pseudo pour le classement :", username || "");
            if (!username) username = "Anonyme";
            localStorage.setItem('tetrisUser', username);
        }
        document.getElementById('userBar').textContent = `Tu joues en tant que : ${username}`;
    }
    askUsername(true);

    // === Leaderboard ===
    function renderLeaderboard() {
        leaderboard.sort((a, b) => b.score - a.score);
        let tbody = document.querySelector('#lbTable tbody');
        tbody.innerHTML = "";
        leaderboard.slice(0, 10).forEach((entry, idx) => {
            let row = document.createElement('tr');
            row.innerHTML = `<td>${idx + 1}</td><td>${entry.user}</td><td>${entry.score}</td>`;
            tbody.appendChild(row);
        });
    }
    function fetchLeaderboard() {
        fetch(BIN_URL, { headers: { "X-Master-Key": API_KEY } })
        .then(res => res.json())
        .then(data => {
            leaderboard = data.record.scores || [];
            renderLeaderboard();
        });
    }
    function updateLeaderboard(newScore) {
        let found = false;
        leaderboard = leaderboard.map(entry => {
            if (entry.user === username) {
                found = true;
                return { user: username, score: Math.max(newScore, entry.score) };
            }
            return entry;
        });
        if (!found) leaderboard.push({ user: username, score: newScore });
        fetch(BIN_URL, {
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "X-Master-Key": API_KEY
            },
            body: JSON.stringify({ scores: leaderboard })
        }).then(() => renderLeaderboard());
    }

    // === TETRIS ===
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    context.scale(20, 20);

    const arena = createMatrix(17, 20);
    const player = { pos: { x: 5, y: 0 }, matrix: null, score: 0, lines: 0, level: 1 };
    const scoreDisplay = document.getElementById('score');
    const linesDisplay = document.getElementById('lines');
    const levelDisplay = document.getElementById('level');
    const timerDisplay = document.getElementById('timer');
    const music = document.getElementById('bgMusic');
    const pauseBtn = document.getElementById('pauseBtn');
    const gameOverMsg = document.getElementById('gameOverMsg');
    const levelAnim = document.getElementById('levelAnim');

    let startTime = Date.now();
    let dropInterval = 600;
    let pieceBag = [];
    let paused = false;
    let isGameOver = false;

    // Unblock music on user interaction
    function unlockMusic() {
        if (music.paused) music.play().catch(() => {});
        document.removeEventListener('click', unlockMusic);
        document.removeEventListener('keydown', unlockMusic);
        document.removeEventListener('touchstart', unlockMusic);
    }
    document.addEventListener('click', unlockMusic);
    document.addEventListener('keydown', unlockMusic);
    document.addEventListener('touchstart', unlockMusic);

    // Empêcher scroll avec fleches/bas/espace
    window.addEventListener("keydown", function(e) {
        if(['ArrowLeft','ArrowRight','ArrowDown',' '].includes(e.key)) {
            e.preventDefault();
        }
    }, {passive: false});

    function togglePause() {
        paused = !paused;
        if (paused) {
            pauseBtn.textContent = "Reprendre";
        } else {
            pauseBtn.textContent = "Pause";
            requestAnimationFrame(update);
        }
    }

    function showLevelAnim(lvl) {
        levelAnim.textContent = `Niveau ${lvl}!`;
        levelAnim.style.display = 'block';
        setTimeout(() => { levelAnim.style.display = 'none'; }, 1100);
    }
    function showGameOver() {
        isGameOver = true;
        gameOverMsg.style.display = 'block';
        gameOverMsg.textContent = "GAME OVER";
    }
    function hideGameOver() {
        isGameOver = false;
        gameOverMsg.style.display = 'none';
    }
    function randomPieceType() {
        if (pieceBag.length === 0) {
            pieceBag = 'TOLJISZ'.split('');
            for (let i = pieceBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieceBag[i], pieceBag[j]] = [pieceBag[j], pieceBag[i]];
            }
        }
        return pieceBag.pop();
    }
    function restartGame() {
        askUsername(true);
        arena.forEach(row => row.fill(0));
        player.score = 0;
        player.lines = 0;
        player.level = 1;
        dropInterval = 600;
        updateMusicSpeed();
        hideGameOver();
        playerReset();
        updateScore();
        startTime = Date.now();
        paused = false;
        pauseBtn.textContent = "Pause";
        requestAnimationFrame(update);
    }
    function updateMusicSpeed() {
        music.playbackRate = 1 + (player.level - 1) * 0.1;
    }
    function updateTimer() {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        timerDisplay.textContent = `Temps: ${elapsed}s`;
    }
    setInterval(updateTimer, 1000);

    function createMatrix(w, h) {
        const matrix = [];
        while (h--) matrix.push(new Array(w).fill(0));
        return matrix;
    }
    function createPiece(type) {
        switch (type) {
            case 'T': return [[0,0,0],[1,1,1],[0,1,0]];
            case 'O': return [[2,2],[2,2]];
            case 'L': return [[0,3,0],[0,3,0],[0,3,3]];
            case 'J': return [[0,4,0],[0,4,0],[4,4,0]];
            case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
            case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
            case 'Z': return [[7,7,0],[0,7,7],[0,0,0]];
        }
    }
    function drawMatrix(matrix, offset) {
        const colors = [null, '#4B0082', '#6A0DAD', '#7B68EE', '#8A2BE2', '#00BFFF', '#1E90FF', '#4169E1'];
        matrix.forEach((row, y) => row.forEach((value, x) => {
            if (value !== 0) {
                context.fillStyle = colors[value];
                context.fillRect(x + offset.x, y + offset.y, 1, 1);
            }
        }));
    }
    function merge(arena, player) {
        player.matrix.forEach((row, y) => row.forEach((value, x) => {
            if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
        }));
    }
    function collide(arena, player) {
        const m = player.matrix;
        const o = player.pos;
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0) {
                    if (o.x + x < 0 || o.x + x >= arena[0].length || o.y + y >= arena.length) {
                        return true;
                    }
                    if (arena[o.y + y] && arena[o.y + y][o.x + x] !== 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function arenaSweep() {
        let rowCount = 1;
        outer: for (let y = arena.length - 1; y >= 0; y--) {
            for (let x = 0; x < arena[y].length; x++) {
                if (arena[y][x] === 0) continue outer;
            }
            const row = arena.splice(y, 1)[0].fill(0);
            arena.unshift(row);
            y++;
            player.score += rowCount * 100;
            player.lines++;
            if (player.lines % 6 === 0) {
                player.level++;
                dropInterval = Math.max(50, dropInterval - 50);
                updateMusicSpeed();
                showLevelAnim(player.level);
            }
            rowCount *= 2;
        }
    }
    function playerDrop() {
        if (paused || isGameOver) return;
        player.pos.y++;
        if (collide(arena, player)) {
            player.pos.y--;
            merge(arena, player);
            arenaSweep();
            let prev = leaderboard.find(entry => entry.user === username);
            if (!prev || player.score > prev.score) {
                updateLeaderboard(player.score);
            }
            updateScore();
            playerReset();
        }
        dropCounter = 0;
    }
    function playerReset() {
        player.matrix = createPiece(randomPieceType());
        player.pos.y = 0;
        player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
        if (collide(arena, player)) {
            showGameOver();
            return;
        }
    }
    function updateScore() {
        scoreDisplay.textContent = `Score: ${player.score}`;
        linesDisplay.textContent = `Lignes: ${player.lines}`;
        levelDisplay.textContent = `Niveau: ${player.level}`;
    }
    function rotate(matrix, dir = 1) {
        for (let y = 0; y < matrix.length; ++y)
            for (let x = 0; x < y; ++x)
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        dir > 0 ? matrix.forEach(row => row.reverse()) : matrix.reverse();
    }

    document.addEventListener('keydown', event => {
        // Empêche tout mouvement si pause ou game over
        if (paused || isGameOver) return;
        if (event.key === 'ArrowLeft') {
            player.pos.x--;
            if (collide(arena, player)) player.pos.x++;
        } else if (event.key === 'ArrowRight') {
            player.pos.x++;
            if (collide(arena, player)) player.pos.x--;
        } else if (event.key === 'ArrowDown') {
            playerDrop();
        } else if (event.key === ' ') {
            rotate(player.matrix);
            if (collide(arena, player)) {
                player.pos.x++;
                if (collide(arena, player)) player.pos.x -= 2;
                if (collide(arena, player)) rotate(player.matrix, -1);
            }
        }
    });

    // Contrôles tactiles simples pour mobile
    let touchStartX = null, touchStartY = null;
    canvas.addEventListener('touchstart', e => {
        if (paused || isGameOver) return;
        if (e.touches.length === 1) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }
    });
    canvas.addEventListener('touchend', e => {
        if (paused || isGameOver) return;
        if (touchStartX !== null && e.changedTouches.length === 1) {
            let dx = e.changedTouches[0].clientX - touchStartX;
            let dy = e.changedTouches[0].clientY - touchStartY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 20) { // swipe right
                    player.pos.x++;
                    if (collide(arena, player)) player.pos.x--;
                } else if (dx < -20) { // swipe left
                    player.pos.x--;
                    if (collide(arena, player)) player.pos.x++;
                }
            } else {
                if (dy > 20) { // swipe down
                    playerDrop();
                } else if (dy < -20) { // swipe up (rotation)
                    rotate(player.matrix);
                    if (collide(arena, player)) {
                        player.pos.x++;
                        if (collide(arena, player)) player.pos.x -= 2;
                        if (collide(arena, player)) rotate(player.matrix, -1);
                    }
                }
            }
        }
        touchStartX = null; touchStartY = null;
    });

    let dropCounter = 0, lastTime = 0;
    function update(time = 0) {
        if (paused || isGameOver) return;
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) playerDrop();

        context.fillStyle = '#111122';
        context.fillRect(0, 0, canvas.width, canvas.height);

        drawMatrix(arena, { x: 0, y: 0 });
        drawMatrix(player.matrix, player.pos);

        requestAnimationFrame(update);
    }

    fetchLeaderboard();
    playerReset();
    updateScore();
    update();
</script>
</body>
</html>
