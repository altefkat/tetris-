<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Leaderboard BG</title>
    <style>
        html, body {
            margin: 0; padding: 0;
            background: url('./background.png') center center / cover no-repeat;
        }
        body {
            text-align: center;
            font-family: Arial, sans-serif;
            color: #ddd;
            min-height: 100vh;
        }
        #container {
            max-width: 420px;
            margin: auto;
            padding: 0 6px;
        }
        canvas {
            border: 4px solid #6A0DAD;
            border-radius: 12px;
            box-shadow: 0 0 20px #6A0DAD, 0 0 40px #220044;
            display: block;
            margin: 20px auto 8px auto;
            background-color: rgba(0, 0, 0, 0.7);
            width: 100%;
            max-width: 340px;
            height: auto;
            aspect-ratio: 17 / 20;
            touch-action: none;
        }
        #pauseBar {
            margin: 12px auto 8px auto;
            width: 160px;
            padding: 7px 0;
            border-radius: 10px;
            background: #35006a;
            color: #fff;
            font-size: 19px;
            letter-spacing: 1px;
            box-shadow: 0 0 8px #6A0DAD55;
            cursor: pointer;
            display: block;
            transition: background 0.2s;
            user-select: none;
            font-weight: bold;
        }
        #pauseBar.paused {
            animation: blink 1s step-end infinite;
            background: #a31481;
            color: #ffe;
        }
        @keyframes blink {
            50% { background: #6A0DAD; color: #fff; }
        }
        #leaderboard {
            margin: 10px auto 18px auto;
            width: 98%;
            background: rgba(16, 7, 30, 0.9);
            border-radius: 12px;
            box-shadow: 0 0 8px #6A0DAD;
            padding: 10px;
            color: #fff;
            font-size: 15px;
        }
        #leaderboard th, #leaderboard td {
            padding: 3px 6px;
        }
        #userBar {
            margin: 10px 0 5px 0;
            font-size: 16px;
            font-weight: bold;
        }
        #changeUserBtn {
            margin-left: 12px;
            font-size: 13px;
            background: #6A0DAD;
            border: none;
            border-radius: 6px;
            color: #fff;
            padding: 4px 8px;
            cursor: pointer;
        }
        #controls {
            display: none;
            margin: 0 auto 10px auto;
            width: 98%;
            max-width: 410px;
        }
        .ctrl-btn {
            display: inline-block;
            background: #3a156d;
            color: #fff;
            border: none;
            border-radius: 10px;
            margin: 4px 5px;
            padding: 16px 20px;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 0 12px #6A0DAD33;
            user-select: none;
            touch-action: manipulation;
        }
        #pauseBtn { display: none; }
        @media (max-width: 600px) {
            #container { max-width: 100vw; }
            canvas { max-width: 100vw; }
            #controls, #pauseBtn { display: block; }
            #leaderboard, #userBar { font-size: 13px; }
            .ctrl-btn { padding: 12px 13px; font-size: 19px; }
        }
        /* ... styles modaux et level up ... (garde les styles précédents pour GAME OVER & Level Up) ... */
        #gameOverModal {
            position: fixed;
            left: 0; right: 0; top: 0; bottom: 0;
            background: rgba(8,0,20,0.88);
            z-index: 999;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #gameOverBox {
            background: #15012a;
            border: 4px solid #6A0DAD;
            border-radius: 16px;
            box-shadow: 0 0 30px #8a2be2, 0 0 90px #000 inset;
            padding: 36px 30px 30px 30px;
            min-width: 260px;
            min-height: 120px;
            animation: goBoxPop 0.4s;
        }
        @keyframes goBoxPop {
            0% { transform: scale(0.4); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        #goTitle {
            font-size: 2.5rem;
            color: #ec68f4;
            margin-bottom: 8px;
            letter-spacing: 2px;
            animation: neonFlicker 1.2s infinite alternate;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        @keyframes neonFlicker {
            0% { text-shadow: 0 0 7px #ff9fff, 0 0 20px #fff, 0 0 40px #a050ec; }
            40% { text-shadow: 0 0 8px #ee2cff, 0 0 28px #fff, 0 0 32px #ff68ec; }
            100% { text-shadow: 0 0 10px #ff9fff, 0 0 36px #fff, 0 0 52px #a050ec; }
        }
        #goScore {
            font-size: 1.3rem;
            margin: 10px 0 18px 0;
            color: #c2b6ff;
        }
        #goRestart {
            margin-top: 8px;
            padding: 11px 32px;
            font-size: 1.25rem;
            border-radius: 10px;
            border: none;
            background: linear-gradient(90deg, #6A0DAD 40%, #8A2BE2 100%);
            color: #fff;
            font-weight: bold;
            box-shadow: 0 0 18px #6000ac77;
            cursor: pointer;
            transition: background 0.2s;
        }
        #goRestart:hover {
            background: linear-gradient(90deg, #8A2BE2 0%, #6A0DAD 100%);
            color: #fff;
        }
        #levelUpOverlay {
            display: none;
            position: fixed;
            left: 0; right: 0; top: 0; bottom: 0;
            z-index: 998;
            pointer-events: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: none;
        }
        #levelUpText {
            font-size: 3rem;
            color: #00ffff;
            font-family: 'Orbitron', 'Arial', monospace;
            text-shadow: 0 0 25px #fff, 0 0 60px #18a5fa, 0 0 18px #6A0DAD;
            padding: 25px 36px;
            border-radius: 15px;
            background: rgba(25, 20, 80, 0.23);
            border: 3px solid #0ff;
            opacity: 0;
            transform: scale(0.7);
            animation: levelup-pop 1.2s cubic-bezier(.2,1.4,.53,1.01) forwards;
        }
        @keyframes levelup-pop {
            0% { opacity: 0; transform: scale(0.5);}
            30% { opacity: 1; transform: scale(1.15);}
            70% { opacity: 1; transform: scale(1);}
            100% { opacity: 0; transform: scale(0.5);}
        }
    </style>
</head>
<body>
<div id="container">
    <h1>Tetris pour les bg</h1>
    <div id="userBar"></div>
    <audio id="bgMusic" src="./music.mp3" autoplay loop></audio>
    <div>
        <span id="score">Score: 0</span> | 
        <span id="lines">Lignes: 0</span> | 
        <span id="level">Niveau: 1</span> | 
        <span id="timer">Temps: 0s</span>
    </div>
    <button onclick="restartGame()">Redémarrer</button>
    <div id="pauseBar" onclick="togglePause()">⏸ Pause</div>
    <div id="controls">
        <button class="ctrl-btn" id="btnLeft">◀️</button>
        <button class="ctrl-btn" id="btnRotate">⟳</button>
        <button class="ctrl-btn" id="btnRight">▶️</button>
        <button class="ctrl-btn" id="btnDown">⬇️</button>
        <button class="ctrl-btn" id="pauseBtn" onclick="togglePause()">⏸</button>
    </div>
    <canvas id="tetris" width="340" height="400"></canvas>
    <div id="leaderboard">
        <b>Leaderboard mondial</b>
        <table id="lbTable" style="width:100%;margin-top:5px;">
            <thead><tr><th>Pos</th><th>Pseudo</th><th>Score</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<!-- GAME OVER MODAL -->
<div id="gameOverModal">
    <div id="gameOverBox">
        <div id="goTitle">GAME OVER</div>
        <div id="goScore"></div>
        <button id="goRestart" onclick="closeGameOver()">Relancer</button>
    </div>
</div>
<!-- LEVEL UP OVERLAY -->
<div id="levelUpOverlay">
    <div id="levelUpText"></div>
</div>
<script>
    // Débloque la musique uniquement sur le premier clic/touch
    function unlockMusic() {
        const audio = document.getElementById('bgMusic');
        if (audio && audio.paused) audio.play().catch(()=>{});
        document.removeEventListener('touchstart', unlockMusic);
        document.removeEventListener('click', unlockMusic);
    }
    document.addEventListener('touchstart', unlockMusic, { once: true });
    document.addEventListener('click', unlockMusic, { once: true });

    // === LEADERBOARD JSONBIN ===
    const API_KEY = "$2a$10$QaIl/jNblmE41X0hexsVMeqBDs68V0Hpu9nSNXw7BYEcYiVWEHd4K";
    const BIN_ID = "6825bd578561e97a5014584f";
    const BIN_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
    let leaderboard = [];
    let username = null;

    function setUsername(force = false) {
        username = localStorage.getItem('tetrisUser');
        if (!username || force) {
            username = prompt("Entrez votre pseudo pour le classement :", username || "");
            if (!username) username = "Anonyme";
            localStorage.setItem('tetrisUser', username);
        }
        document.getElementById('userBar').innerHTML =
            `Tu joues en tant que : <b>${username}</b>
            <button id="changeUserBtn" onclick="setUsername(true)">Changer</button>`;
    }
    window.setUsername = setUsername;
    setUsername();

    function renderLeaderboard() {
        leaderboard.sort((a, b) => b.score - a.score);
        let tbody = document.querySelector('#lbTable tbody');
        tbody.innerHTML = "";
        leaderboard.slice(0, 10).forEach((entry, idx) => {
            let row = document.createElement('tr');
            row.innerHTML = `<td>${idx + 1}</td><td>${entry.user}</td><td>${entry.score}</td>`;
            tbody.appendChild(row);
        });
    }
    function fetchLeaderboard() {
        fetch(BIN_URL, { headers: { "X-Master-Key": API_KEY } })
        .then(res => res.json())
        .then(data => {
            leaderboard = data.record.scores || [];
            renderLeaderboard();
        });
    }
    function updateLeaderboard(newScore) {
        let found = false;
        leaderboard = leaderboard.map(entry => {
            if (entry.user === username) {
                found = true;
                return { user: username, score: Math.max(newScore, entry.score) };
            }
            return entry;
        });
        if (!found) leaderboard.push({ user: username, score: newScore });
        fetch(BIN_URL, {
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "X-Master-Key": API_KEY
            },
            body: JSON.stringify({ scores: leaderboard })
        }).then(() => renderLeaderboard());
    }

    // === TETRIS ===
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');

    function resizeCanvas() {
        // Responsive en gardant un vrai ratio de 17x20
        let parentW = Math.min(canvas.parentNode.offsetWidth, 420);
        let ratio = window.devicePixelRatio || 1;
        let baseWidth = 340;
        let baseHeight = 400;
        // calcul largeur réelle (max) + respect ratio
        let newWidth = parentW;
        let newHeight = parentW * (baseHeight / baseWidth);
        canvas.width = Math.round(newWidth * ratio);
        canvas.height = Math.round(newHeight * ratio);
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.scale((canvas.width / 17) / 20, (canvas.height / 20) / 20);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const arena = createMatrix(17, 20);
    const player = { pos: { x: 5, y: 0 }, matrix: null, score: 0, lines: 0, level: 1 };
    const scoreDisplay = document.getElementById('score');
    const linesDisplay = document.getElementById('lines');
    const levelDisplay = document.getElementById('level');
    const timerDisplay = document.getElementById('timer');
    const pauseBar = document.getElementById('pauseBar');
    const gameOverModal = document.getElementById('gameOverModal');
    const goScore = document.getElementById('goScore');
    const levelUpOverlay = document.getElementById('levelUpOverlay');
    const levelUpText = document.getElementById('levelUpText');
    let paused = false, isGameOver = false;

    let startTime = Date.now();
    let pausedTime = 0, pauseStart = 0;
    let dropInterval = 600;
    let pieceBag = [];
    let pendingLevelUp = false;

    function randomPieceType() {
        if (pieceBag.length === 0) {
            pieceBag = 'TOLJISZ'.split('');
            for (let i = pieceBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieceBag[i], pieceBag[j]] = [pieceBag[j], pieceBag[i]];
            }
        }
        return pieceBag.pop();
    }

    function restartGame() {
        arena.forEach(row => row.fill(0));
        player.score = 0;
        player.lines = 0;
        player.level = 1;
        dropInterval = 600;
        updateMusicSpeed();
        playerReset();
        updateScore();
        startTime = Date.now();
        pausedTime = 0;
        paused = false;
        isGameOver = false;
        updatePauseBar();
        gameOverModal.style.display = "none";
    }

    function updateMusicSpeed() {
        const audio = document.getElementById('bgMusic');
        audio.playbackRate = 1 + (player.level - 1) * 0.1;
    }

    function updateTimer() {
        let realTime = Date.now();
        const elapsed = Math.floor(((realTime - startTime) - pausedTime) / 1000);
        timerDisplay.textContent = `Temps: ${elapsed}s`;
    }
    setInterval(updateTimer, 1000);

    function createMatrix(w, h) {
        const matrix = [];
        while (h--) matrix.push(new Array(w).fill(0));
        return matrix;
    }

    function createPiece(type) {
        switch (type) {
            case 'T': return [[0,0,0],[1,1,1],[0,1,0]];
            case 'O': return [[2,2],[2,2]];
            case 'L': return [[0,3,0],[0,3,0],[0,3,3]];
            case 'J': return [[0,4,0],[0,4,0],[4,4,0]];
            case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
            case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
            case 'Z': return [[7,7,0],[0,7,7],[0,0,0]];
        }
    }

    function drawMatrix(matrix, offset) {
        const colors = [null, '#4B0082', '#6A0DAD', '#7B68EE', '#8A2BE2', '#00BFFF', '#1E90FF', '#4169E1'];
        matrix.forEach((row, y) => row.forEach((value, x) => {
            if (value !== 0) {
                context.fillStyle = colors[value];
                context.fillRect(x + offset.x, y + offset.y, 1, 1);
            }
        }));
    }

    function merge(arena, player) {
        player.matrix.forEach((row, y) => row.forEach((value, x) => {
            if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
        }));
    }

    function collide(arena, player) {
        const m = player.matrix;
        const o = player.pos;
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0) {
                    if (o.x + x < 0 || o.x + x >= arena[0].length || o.y + y >= arena.length) {
                        return true;
                    }
                    if (arena[o.y + y] && arena[o.y + y][o.x + x] !== 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function arenaSweep() {
        let rowCount = 1;
        outer: for (let y = arena.length - 1; y >= 0; y--) {
            for (let x = 0; x < arena[y].length; x++) {
                if (arena[y][x] === 0) continue outer;
            }
            const row = arena.splice(y, 1)[0].fill(0);
            arena.unshift(row);
            y++;
            player.score += rowCount * 100;
            player.lines++;
            let prevLevel = player.level;
            if (player.lines % 6 === 0) {
                player.level++;
                dropInterval = Math.max(50, dropInterval - 50);
                updateMusicSpeed();
                pendingLevelUp = player.level;
                showLevelUp(player.level);
            }
            rowCount *= 2;
        }
    }

    function playerDrop() {
        player.pos.y++;
        if (collide(arena, player)) {
            player.pos.y--;
            merge(arena, player);
            arenaSweep();
            let prev = leaderboard.find(entry => entry.user === username);
            if (!prev || player.score > prev.score) {
                updateLeaderboard(player.score);
            }
            updateScore();
            playerReset();
        }
        dropCounter = 0;
    }

    function playerReset() {
        player.matrix = createPiece(randomPieceType());
        player.pos.y = 0;
        player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
        if (collide(arena, player)) {
            isGameOver = true;
            showGameOver();
        }
    }

    function updateScore() {
        scoreDisplay.textContent = `Score: ${player.score}`;
        linesDisplay.textContent = `Lignes: ${player.lines}`;
        levelDisplay.textContent = `Niveau: ${player.level}`;
    }

    function rotate(matrix, dir = 1) {
        for (let y = 0; y < matrix.length; ++y)
            for (let x = 0; x < y; ++x)
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        dir > 0 ? matrix.forEach(row => row.reverse()) : matrix.reverse();
    }

    function showLevelUp(level) {
        levelUpOverlay.style.display = "flex";
        levelUpText.textContent = `⟫ Niveau ${level} ! ⟪`;
        levelUpText.style.animation = "none";
        void levelUpText.offsetWidth;
        levelUpText.style.animation = null;
        setTimeout(() => { levelUpOverlay.style.display = "none"; }, 1200);
    }

    function showGameOver() {
        goScore.textContent = `Ton score final : ${player.score}`;
        gameOverModal.style.display = "flex";
    }
    function closeGameOver() {
        gameOverModal.style.display = "none";
        restartGame();
    }
    window.closeGameOver = closeGameOver;
    window.addEventListener('keydown', (e) => {
        if (isGameOver && (e.key === " " || e.key === "Enter")) {
            closeGameOver();
        }
    });

    function updatePauseBar() {
        if (paused) {
            pauseBar.innerHTML = "▶️ Reprendre";
            pauseBar.classList.add("paused");
        } else {
            pauseBar.innerHTML = "⏸ Pause";
            pauseBar.classList.remove("paused");
        }
    }
    function togglePause() {
        if (isGameOver) return;
        paused = !paused;
        if (paused) pauseStart = Date.now();
        else pausedTime += Date.now() - pauseStart;
        updatePauseBar();
    }
    window.togglePause = togglePause;

    window.addEventListener('keydown', (e) => {
        if (isGameOver) return;
        if (e.key === "p" || e.key === "P") togglePause();
        if (paused) return;
        if (e.key === 'ArrowLeft') moveLeft();
        else if (e.key === 'ArrowRight') moveRight();
        else if (e.key === 'ArrowDown') playerDrop();
        else if (e.key === ' ') rotatePiece();
    });

    // Touch UI
    function moveLeft() { player.pos.x--; if (collide(arena, player)) player.pos.x++; }
    function moveRight() { player.pos.x++; if (collide(arena, player)) player.pos.x--; }
    function rotatePiece() {
        rotate(player.matrix);
        if (collide(arena, player)) {
            player.pos.x++;
            if (collide(arena, player)) player.pos.x -= 2;
            if (collide(arena, player)) rotate(player.matrix, -1);
        }
    }
    function setupTouchControls() {
        if ('ontouchstart' in window) {
            document.getElementById('controls').style.display = "block";
        }
        document.getElementById('btnLeft').addEventListener('click', () => { if(!paused && !isGameOver) moveLeft(); });
        document.getElementById('btnRight').addEventListener('click', () => { if(!paused && !isGameOver) moveRight(); });
        document.getElementById('btnDown').addEventListener('click', () => { if(!paused && !isGameOver) playerDrop(); });
        document.getElementById('btnRotate').addEventListener('click', () => { if(!paused && !isGameOver) rotatePiece(); });
    }
    // Swipe gesture
    let touchStartX = null, touchStartY = null;
    canvas.addEventListener('touchstart', function(e) {
        if (e.touches.length === 1) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }
    });
    canvas.addEventListener('touchend', function(e) {
        if (touchStartX !== null && e.changedTouches.length === 1 && !paused && !isGameOver) {
            let dx = e.changedTouches[0].clientX - touchStartX;
            let dy = e.changedTouches[0].clientY - touchStartY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 30) moveRight();
                if (dx < -30) moveLeft();
            } else {
                if (dy > 40) playerDrop();
                if (dy < -40) rotatePiece();
            }
            touchStartX = touchStartY = null;
        }
    });

    fetchLeaderboard();
    playerReset();
    updateScore();
    updatePauseBar();
    setupTouchControls();
    update();
</script>
</body>
</html>
